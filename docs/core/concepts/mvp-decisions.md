# Архитектурные решения для MVP

> **Принятые решения по ключевым архитектурным вопросам для первой версии**

---

## Контекст

При проектировании ClearMethod возникли ключевые архитектурные вопросы, требующие явных решений. Этот документ фиксирует решения, принятые для MVP, с обоснованием выборов.

**Принцип**: Для MVP выбираем **простоту** над **полнотой**. Сложные механизмы добавляем позже, когда появится реальная необходимость.

---

## 1. Типизация

### Вопрос
Нужна ли строгая типизация свойств и параметров методов?

### Решение для MVP: Мягкая типизация

Указываем типы как **подсказки** для ИИ, но не валидируем строго.

```yaml
parameters:
  - name: task_id
    type: string         # Подсказка
  - name: priority
    type: string         # "low", "medium", "high"
  - name: deadline
    type: datetime       # ISO8601 формат
```

**Обоснование**:
- ✅ ИИ понимает типы из контекста
- ✅ Минимум синтаксиса = проще начать
- ✅ Не нужен отдельный валидатор
- ✅ Быстрее итерировать

### Для будущего: Строгая типизация

Постепенно добавим:
- Enum'ы для ограниченных значений
- Валидацию форматов (email, url, date)
- JSON Schema для сложных объектов
- Compile-time проверки

```yaml
# Будущее
parameters:
  - name: priority
    type: enum
    values: ["low", "medium", "high"]
    default: "medium"
  - name: email
    type: string
    format: email
    validation: "^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$"
```

---

## 2. Транзакции и откат ошибок

### Вопрос
Как обрабатывать ошибки в середине выполнения метода? Нужен ли откат изменений?

### Решение для MVP: Оптимистичный подход

- Не откатываем автоматически
- Логируем ошибку детально
- ИИ объясняет пользователю состояние
- Пользователь принимает решение (исправить или откатить вручную)

```yaml
execute:
  - do: "Create folder /tasks/TASK-123"  # Успех
  - do: "Create file status.yml"         # Успех
  - do: "Write invalid YAML"             # ОШИБКА!

on_error:
  - do: TASK.log("ERROR at step 3: {error_message}")
  - do: "Report to user: 'Task partially created. Manual cleanup needed.'"
  - do: "Suggest: Remove folder /tasks/TASK-123 or fix status.yml"
```

**Обоснование**:
- ✅ Простая реализация
- ✅ Прозрачность - пользователь видит что произошло
- ✅ Гибкость - пользователь решает как исправить
- ✅ Не нужна сложная логика отката

### Для будущего: Транзакционность

Добавим:
- Checkpoints перед критичными операциями
- Автоматический rollback при ошибке
- Лог изменений для отката

```yaml
# Будущее
execute:
  - checkpoint: before_critical_operation
  - do: "Critical operation"
  - on_error:
      rollback: before_critical_operation
```

---

## 3. Параллелизм

### Вопрос
Может ли один агент работать с несколькими задачами одновременно?

### Решение для MVP: Одна задача = один агент

- Один агент работает только с одной активной задачей
- Явное переключение через команду `/cm-switch TASK-XXX`
- Контекст очищается при переключении

**Сценарий**:
```
User: "/cm-start TASK-123"
Agent: [Работает над TASK-123]

User: "/cm-start TASK-124"
Agent: "Уже работаю над TASK-123. 
        Варианты:
        1. /cm-complete - завершить TASK-123
        2. /cm-switch TASK-124 - переключиться (TASK-123 приостановится)"
```

**Обоснование**:
- ✅ Простая модель
- ✅ Нет конфликтов контекста
- ✅ Легко отлаживать
- ✅ Явная фокусировка

### Для будущего: Контекстное переключение

Добавим:
- Свойство `AGENT.current_task`
- Сохранение контекста задачи при переключении
- Список активных задач
- Автоматическое переключение контекста

---

## 4. Композиция методов

### Вопрос
Может ли один метод вызывать другой метод того же концепта?

### Решение для MVP: Полная поддержка

**Однозначно ДА** - это фундаментально для переиспользования.

```yaml
# TASK.create() вызывает вспомогательные методы
method: create
execute:
  - do: TASK.initialize_folder(task_id)
  - do: TASK.create_status_file(task_id, workflow_id)
  - do: TASK.log(task_id, "Task created")

# Вспомогательный метод
method: initialize_folder
execute:
  - let: folder = ".cm/tasks/{task_id}"
  - do: "Create folder {folder}"
```

**Принципы**:
- ✅ Методы своего концепта - всегда можно
- ✅ Методы других концептов - всегда можно
- ✅ Рекурсия - разрешена (с осторожностью)

**Обоснование**:
- ✅ Естественная практика программирования
- ✅ DRY principle
- ✅ Упрощает сложные методы
- ✅ Улучшает читаемость

---

## 5. Версионирование

### Вопрос
Как развивать концепты без breaking changes?

### Решение для MVP: Не версионируем

- Все в одной версии
- Breaking changes допустимы (нет пользователей = нет legacy)
- Фокус на функциональности, не на совместимости

**Обоснование**:
- ✅ Не тратим время на version management
- ✅ Свободно итерируем архитектуру
- ✅ Проще рефакторить

### Для будущего: Семантическое версионирование

Когда появятся пользователи:

```yaml
# Концепт с версией
concept: TASK
version: 2.0.0
backward_compatible_with: [1.x]

# Метод с версией
method: create
version: 1.0.0
deprecated_in: 2.0.0
replaced_by: create_v2
migration_guide: "docs/migration/create-v1-to-v2.md"
```

**Стратегии**:
- Версия в пути: `TASK.v1.create()`
- Обратная совместимость через адаптеры
- Deprecated warnings
- Миграционные гайды

---

## 6. Условные переходы (Guard Conditions)

### Вопрос
Где описывать guard conditions - в workflow или в состояниях?

### Решение для MVP: В workflow

Guard conditions описываются в файле workflow, а **не** в состояниях.

```yaml
# ✅ Правильно - в workflow.yml
transitions:
  - from: analyzing
    to: designing
    guard: TASK.get_property("complexity") == "high"
    
  - from: analyzing
    to: implementing  # Пропускаем дизайн
    guard: TASK.get_property("complexity") == "trivial"
```

```yaml
# ❌ Неправильно - в состоянии
# states/analyzing.yml
postconditions:
  - if: complexity == "high"
    then: next_state = "designing"  # Знание о другом состоянии!
```

**Обоснование**:
- ✅ Соблюдает принцип изоляции состояний
- ✅ Вся логика переходов в одном месте (workflow.yml)
- ✅ Легко визуализировать граф
- ✅ Легко добавлять/изменять маршруты
- ✅ Состояния остаются переиспользуемыми

**Механика**:
1. Состояние устанавливает свойства в postconditions
2. Workflow проверяет guard conditions для выбора перехода
3. Команда `/cm-next` анализирует guards и предлагает варианты

---

## 7. Хранение задач

### Вопрос
Какое пакет использовать для хранения задач в MVP?

### Решение для MVP: FILE_TASK

Простое файловое хранилище без канбан-логики.

**Структура**:
```
.cm/
  tasks/
    TASK-123/
      status.yml
      specs.md
      design.md
      log.md
```

**Обоснование**:
- ✅ Максимально простая реализация
- ✅ Легко отлаживать (просто файлы)
- ✅ Фокус на концептах, а не на организации
- ✅ Можно легко расширить до KANBAN позже

### Альтернативы (для будущего)
- FILE-KANBAN - папки как колонки
- MCP-TASK - интеграция с внешними трекерами
- DB-TASK - хранение в БД

---

## 8. Workflow для MVP

### Вопрос
Какой workflow реализовать первым?

### Решение: Feature Workflow с анализом и планированием

7 состояний, линейный процесс:

```
CREATING → ANALYZING → DESIGNING → PLANNING → IMPLEMENTING → VERIFYING → COMPLETING
```

**Состояния**:
- **CREATING** - создание задачи, сбор базовой информации
- **ANALYZING** - детальный анализ требований, уточнение, декомпозиция
- **DESIGNING** - проектирование решения, архитектурные решения
- **PLANNING** - создание детального плана реализации
- **IMPLEMENTING** - реализация решения по плану
- **VERIFYING** - проверка, тестирование
- **COMPLETING** - финализация, документация, закрытие

**Почему добавили ANALYZING**:
- Реальный кейс - требования часто нужно анализировать до проектирования
- Разделение concerns - сбор инфо (creating) vs. анализ (analyzing) vs. проектирование (designing)
- Не усложняет реализацию

**Почему добавили PLANNING**:
- Разделение архитектурного мышления (designing) и процедурного (planning)
- Design = ЧТО и КАК на высоком уровне, Plan = В КАКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ конкретно
- Лучшее управление контекстом - implementing получает четкий checklist
- Возможность review плана до начала реализации

**Без**:
- Stage-Based Development (добавим позже)
- VCS интеграция (добавим позже)
- Условных переходов (добавим позже)
- Подпроцессов (добавим позже)

**Обоснование**:
- ✅ Покрывает реальный процесс разработки
- ✅ Демонстрирует все ключевые концепты
- ✅ Достаточно для реальной работы
- ✅ Можно пройти end-to-end
- ✅ Простой для понимания

---

## 9. DSL для методов

### Вопрос
Какой DSL использовать для описания методов?

### Решение для MVP: YAML-based

Декларативный синтаксис на основе YAML.

```yaml
execute:
  - let: folder = ".cm/tasks/{task_id}"
  - do: "Create folder {folder}"
  - if: file_exists("{folder}/status.yml")
    then:
      - error: "Task already exists"
  - do: TASK.log("Created")
```

**Обоснование**:
- ✅ Декларативный (соответствует философии)
- ✅ Легко парсить и валидировать
- ✅ Привычен разработчикам
- ✅ Хорошо читается ИИ
- ✅ Можно добавить другие DSL позже

### Альтернативы (для будущего)
- C-like - императивный синтаксис
- Natural language - инструкции на родном языке

---

## 10. События

### Вопрос
Нужна ли система событий в MVP? Как её реализовать?

### Решение: ✅ Реализовано (basic-events)

**Статус**: Включено в MVP после доработки архитектуры.

События реализованы как:
- `EVENT` - абстрактный концепт в ядре (4-й базовый концепт)
- `BASIC_EVENT` - файловая реализация в расширении `basic-events`

### Архитектурные решения

#### 1. EVENT как концепт ядра

**Решение**: EVENT - это абстрактный концепт, как TASK, WORKFLOW, CONTEXT.

**Альтернативы рассмотрены**:
- ❌ События в ядре без абстракции (жестко зашито)
- ✅ EVENT как abstract concept + реализации в пакетах

**Обоснование**:
- ✅ Единообразие - все концепты работают одинаково
- ✅ Гибкость - можно заменить реализацию (файловая → Redis → Kafka)
- ✅ Архитектурная чистота - нет исключений
- ✅ Тестируемость - можно подменить MOCK_EVENT для тестов

#### 2. Синхронное vs Асинхронное выполнение

**Решение для MVP**: Синхронное выполнение обработчиков.

**Обоснование**:
- ✅ Простая реализация - не нужна очередь задач
- ✅ Предсказуемость - порядок выполнения детерминирован
- ✅ Отладка - легко трассировать последовательность
- ✅ Достаточно для MVP - обработчики быстрые

**Для будущего**: Асинхронные обработчики для долгих операций.

#### 3. Приоритеты обработчиков

**Решение**: Числовые приоритеты (1-200+), меньше = раньше.

**Диапазоны**:
- 1-10: Критичные (валидация, безопасность)
- 11-50: Пре-действия (quality gates)
- 51-100: Нормальные (интеграции)
- 101-200: Пост-действия (уведомления)
- 201+: Низкоприоритетные

**Обоснование**:
- ✅ Явный контроль порядка выполнения
- ✅ Гибкость - точная настройка приоритетов
- ✅ Понятность - меньше = важнее (как Unix nice)

#### 4. Фильтры событий

**Решение**: Объектные фильтры с AND логикой.

```yaml
filter:
  workflow: sbd.feature  # AND
  stage: [designing, implementing]  # OR внутри массива
```

**Обоснование**:
- ✅ Гибкость - точный контроль когда запускать обработчик
- ✅ Производительность - не запускаются лишние обработчики
- ✅ Декларативность - явные условия в подписке

**Для будущего**: Сложные фильтры (regex, functions).

#### 5. Защита от каскадных циклов

**Решение**: Максимальная глубина каскада = 10 уровней.

**Механика**:
```yaml
EVENT.emit("task.created")  # cascade_depth: 0
  → handler → EVENT.emit("vcs.branch_created")  # cascade_depth: 1
    → handler → EVENT.emit("notification.sent")  # cascade_depth: 2
      ... до 10 уровней
```

**Обоснование**:
- ✅ Защита от бесконечных циклов (A → B → A)
- ✅ Явное ограничение глубины
- ✅ Отладка - cascade_depth видно в логе

#### 6. Изоляция ошибок обработчиков

**Решение**: try/catch вокруг каждого обработчика.

**Поведение**:
- Ошибка обработчика логируется
- Статус обработчика: `error`
- Другие обработчики продолжают выполняться

**Обоснование**:
- ✅ Один сломанный обработчик не останавливает систему
- ✅ Прозрачность - видно какой обработчик упал
- ✅ Надежность - система resilient к ошибкам

#### 7. Хранилище событий

**Решение для MVP**: Файловое хранилище (YAML).

```
.cm/events/
  events.yml           # Хронологический лог
  subscriptions.yml    # Активные подписки
```

**Обоснование**:
- ✅ Простота - не нужна БД
- ✅ Прозрачность - можно читать напрямую
- ✅ Git-friendly - текстовый формат
- ✅ Достаточно для MVP

**Для будущего**: Ротация логов, сжатие, индексация.

### Стандартные события

Определен минимальный набор стандартных событий:

**Жизненный цикл задачи**:
- `task.created`, `task.updated`, `task.deleted`
- `task.state_changed`, `task.stage_started`, `task.stage_completed`
- `task.workflow_started`, `task.workflow_completed`

**Качество**:
- `quality.gate_checked`, `quality.gate_passed`, `quality.gate_failed`

**VCS**:
- `vcs.branch_created`, `vcs.commit_created`, `vcs.pr_created`

**Контекст**:
- `context.loaded`, `context.updated`

**Система**:
- `extension.registered`, `command.executed`, `error.occurred`

### Интеграция с пакетами

События позволяют пакетам координироваться без прямых зависимостей:

```yaml
# Workflow эмитит событие
- EVENT.emit("task.created", {task_id: "FEAT-001"})

# Расширения независимо подписываются:
# git-vcs → создает ветку
# qa-gates → устанавливает checklist
# notifications → уведомляет команду
```

**Преимущества**:
- ✅ Слабая связанность (loose coupling)
- ✅ Расширения можно добавлять/удалять без изменения workflow
- ✅ Каждое пакет работает независимо

### Реализация

**Методы EVENT**:
- `emit()` - эмитировать событие
- `subscribe()` - подписать обработчик
- `unsubscribe()` - отписать обработчик
- `get_history()` - получить историю событий
- `list_subscriptions()` - список подписок

**Расширение**: `basic-events.BASIC_EVENT`

**Документация**: См. [events.md](events.md) - детальная документация системы событий

---

## Сводная таблица решений

| Вопрос | MVP | Будущее |
|--------|-----|---------|
| **Типизация** | Мягкая (подсказки) | Строгая (enum, validation) |
| **Транзакции** | Оптимистичный + логи | Checkpoints + rollback |
| **Параллелизм** | Одна задача | Контекстное переключение |
| **Композиция** | ✅ Полная поддержка | ✅ Полная поддержка |
| **Версионирование** | Нет | Semver + обратная совместимость |
| **Guard conditions** | В workflow | В workflow |
| **Хранение задач** | FILE_TASK (реализует TASK) | DATABASE_TASK, MCP_TASK |
| **Workflow** | 6 состояний, линейный | Сложные графы, подпроцессы |
| **DSL** | YAML-based | + C-like, Natural |
| **События** | ✅ BASIC_EVENT (файловое, синхронное) | Redis/Kafka, асинхронность, wildcards |

---

## 11. Абстракции vs Реализации

### Вопрос
Должны ли концепты в ядре быть абстрактными или конкретными?

### Решение для MVP: Разделение интерфейса и реализации

**Абстрактные концепты в core**:
- Определяют только интерфейс (сигнатуры методов)
- Не имеют реализации
- Примеры: TASK, WORKFLOW (в будущем - CONTEXT)

**Конкретные реализации в extensions**:
- Реализуют интерфейсы из ядра
- Содержат фактический код методов
- Примеры: FILE_TASK (implements TASK)

**Пример**:

```yaml
# core/concepts/task.yml - ИНТЕРФЕЙС
concept: TASK
type: abstract
methods:
  - signature: create(id, title, content, creator, workflow)
    returns: void
  - signature: get_state()
    returns: string
  # ... остальные сигнатуры

# packages/file-task/concept.yml - РЕАЛИЗАЦИЯ
concept: FILE_TASK
implements: TASK
type: concrete
methods:
  create: methods/create.yml      # Файл с реализацией
  get_state: methods/get_state.yml
  # ...
```

**Обоснование**:
- ✅ Чистая архитектура - разделение "что" и "как"
- ✅ Гибкость - можно создать DATABASE_TASK, MCP_TASK
- ✅ Независимость ядра от деталей реализации
- ✅ Естественная точка пакета

**Как выбирается реализация**:
```yaml
# config.yml проекта
extensions:
  active:
    - file-task
  
  task_implementation: file-task  # Какую реализацию TASK использовать
```

Агент автоматически маршрутизирует вызовы `TASK.method()` к активной реализации.

---

## Принципы принятия решений

1. **Простота над полнотой** - выбираем минимальное работающее решение
2. **Итеративность** - можем добавить сложность позже
3. **Прагматизм** - решаем реальные проблемы, а не абстрактные
4. **Архитектурная гибкость** - решения MVP не закрывают пути развития
5. **Фокус на концептах** - отрабатываем основные идеи, детали потом
6. **Разделение абстракций и реализаций** - ядро описывает интерфейсы, пакета - имплементации

---

**См. также:**
- [../concepts.md](../concepts.md) - Обзор и философия концептов
- [core.md](core.md) - Концепты ядра
- [extensions.md](extensions.md) - Концепты пакетов
- [advanced.md](advanced.md) - Продвинутые возможности

